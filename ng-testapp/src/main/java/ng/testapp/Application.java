package ng.testapp;

import ng.appserver.NGActionResults;
import ng.appserver.NGApplication;
import ng.appserver.NGRequest;
import ng.appserver.NGResponse;
import ng.appserver.directactions.NGDirectActionRequestHandler;
import ng.plugins.Elements;
import ng.plugins.Routes;
import ng.testapp.components.TAMain;
import ng.testapp.components.TAProgrammaticDynamicComponent;
import ng.testapp.components.TASingleFileComponent;
import ng.testapp.directaction.JSONAction;

public class Application extends NGApplication {

	public static void main( String[] args ) {
		NGApplication.run( args, Application.class );
	}

	/**
	 * Registration of direct action classes is very primitive, since DAs have received little love through ng's development process.
	 *
	 * DAs are still included, mostly because I believe they might be important for migrating older projects (which often contain plenty of DAs).
	 *
	 * But I think actual routes really mostly replace DAs (they give you the static URLs, but in a nicer way)
	 */
	public Application() {
		// FIXME: Just a reminder that this sucks // Hugi 2025-06-19
		NGDirectActionRequestHandler.registerDirectActionClass( DirectAction.class );
		NGDirectActionRequestHandler.registerDirectActionClass( JSONAction.class );
	}

	/**
	 * Demonstrates mapping of URLs to actions in your application (our version of routing, as seen in most web frameworks).
	 *
	 * The route table is generated by invoking super.routes() and then adding routes to it using map().
	 * Route patterns are simple in the current incarnation.
	 * You can map an exact URL, or end the URL pattern with "*" to map everything starting with the given string (as in the /print/* route shown below).
	 * Unlike most other frameworks, we currently don't differentiate between HTTP methods when defining a route, mapping a route will handle the URL, regardless of the request method.
	 * Like most other things, that may change in the future, if we feel it's useful.
	 *
	 * You can .map() a URL to
	 *
	 * 1) A component class (in which case an instance of the component is created and returned)
	 * 2) A function accepting the request as a parameter and returning NGActionResults (Function<NGRequest,NGActionResults)
	 * 3) A method accepting no parameters and returning NGActionResults (Supplier<NGActionResults)
	 * 4) An instance of an NGRequestHandler. In this case you can think of .map like  a fancy version of WO's .registerRequestHandler()
	 */
	@Override
	public Routes routes() {
		return super.routes()

				// The canonical way of mapping the "default request", i.e. requests coming to the site's root.
				// Here mapped to return an instance of TAMain.class (essentially just performing pageWithName( TAMain.class ))
				.map( "/", TAMain.class )

				// A little Hello World demo for demonstration of a wildcard patterned URL
				.map( "/print/*", request -> {
					final String responseContent = "Hello " + request.parsedURI().getString( 1 );

					// Sidenote: You'll see NGResponse's constructors being deprecated.
					// This is because NGResponse and NGRequest will probably be converted to interfaces, with subclasses
					// based on the type of the response/request content (String, byte[], stream, multipart etc.).
					// In that case, generic response construction could be performed using factory methods (NGResponse.of() or something like that)
					// or we'll just allow the user to instantiate the specific implementing classes himself (new NGStringResponse(), new NGMultiPartResponse() etc.)
					return new NGResponse( responseContent, 200 );
				} )

				// Demonstrates mapping a URL to a response-generating method (which accepts the request as a parameter)
				.map( "/response-image", this::imageReponse )

				// Demonstrates mapping a URL to a response-generating method (which accepts no parameters)
				.map( "/response-string", this::stringReponse )

				// Testing a component with a single-file-template
				.map( "/single-file", TASingleFileComponent.class )

				// Testing a classless component with a single-file-template
				.map( "/single-file-classless", request -> pageWithName( "TASingleFileClasslessComponent", request.context() ) )

				// Testing programmatic component generation
				// FIXME: Doesn't really belong in the demo project, find a new home // Hugi 2025-09-27
				.map( "/component-programmatic", TAProgrammaticDynamicComponent.class );
	}

	private NGActionResults stringReponse() {
		return new NGResponse( "I am a string response", 200 );
	}

	private NGActionResults imageReponse( NGRequest request ) {
		final byte[] bytes = application().resourceManager().obtainWebserverResource( "app", "test-image-4.jpg" ).get().bytes();

		final NGResponse response = new NGResponse();
		response.setContentBytes( bytes );
		response.setHeader( "content-type", "image/jpeg" );
		return response;
	}

	/**
	 * FIXME: Implement an example implementation
	 */
	@Override
	public Elements elements() {
		return super.elements();
	}

	//	@Override
	//	public NGResponse dispatchRequest( NGRequest request ) {
	//		logger.info( "uri: {} ", request.uri() );
	//		logger.info( "method: {} ", request.method() );
	//		logger.info( "headers: {} ", request.headers() );
	//		logger.info( "cookieValues: {} ", request.cookieValues() );
	//		logger.info( "formValues: {} ", request.formValues() );
	//		logger.info( "contentString: {}", request.contentString() );
	//		return super.dispatchRequest( request );
	//	}
}