package ng.appserver;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import ng.appserver.templating.NGComponent;
import ng.appserver.templating.NGElementID;

public class NGContext {

	/**
	 * Name of the header or query parameter (form value) added to a request to signify the part(s) of the page we want to render
	 * (as in, the IDs of the updateContainers we want updated)
	 */
	private static final String TARGETED_CONTAINER_ID_PARAM = "ng-container-id";

	/**
	 * If multiple update container IDs are targeted they are separated by this string
	 */
	private static final String MULTIPLE_CONTAINER_SEPARATOR = ";";

	/**
	 * Contains the list of AjaxUpdateContainer IDs that encapsulate the element currently being rendered
	 */
	private List<String> _containingUpdateContainerIDs = new ArrayList<>();

	/**
	 * Indicates that we ignore any update container headers and append every element to the response
	 */
	private boolean _forceFullRender;

	/**
	 * The request that initiated the creation of this context
	 */
	private final NGRequest _request;

	/**
	 * This context's uniqueID within it's session
	 */
	private String _contextID;

	/**
	 * Stores the ID of the context that originated the creation of this context.
	 * Will currently be null if it's the first context in a series of transactions.
	 * Serves the stateful page caching mechanism to track origin of partial pages.
	 *
	 * CHECKME: Still under consideration. Getting this out of the context itself might be nice // Hugi 2024-09-28
	 */
	private String _originatingContextID;

	/**
	 * The page level component
	 */
	private NGComponent _page;

	/**
	 * The component currently being processed by this context
	 */
	private NGComponent _component;

	/**
	 * ID of the element currently being rendered by the context.
	 */
	private NGElementID _elementID;

	/**
	 * In the case of component actions, this is the elementID of the element that invoked the action (clicked a link, submitted a form etc)
	 * Used in combination with _requestContextID to find the proper action to initiate.
	 */
	private NGElementID _senderID;

	/**
	 * Indicates that this context should be saved in the page cache.
	 * Currently, this just means that a context ID has been generated by invoking contextID().
	 * That should usually only happen during the generation of a stateful action URL.
	 */
	private boolean _shouldSaveInPageCache;

	public NGContext( final NGRequest request ) {
		Objects.requireNonNull( request );
		_request = request;
		request.setContext( this );

		// CHECKME: We only need an elementID if we're going to be rendering a component, so theoretically, this could be initialized lazily
		_elementID = new NGElementID();
	}

	/**
	 * @return The request that this context originates from
	 */
	public NGRequest request() {
		return _request;
	}

	/**
	 * @return This context's session, creating a session if none is present.
	 */
	@Deprecated
	public NGSession session() {
		return request().session();
	}

	/**
	 * @return This context's session, or null if no session is present.
	 */
	@Deprecated
	public NGSession existingSession() {
		return request().existingSession();
	}

	/**
	 * @return True if this context has an existing session
	 */
	@Deprecated
	public boolean hasSession() {
		return request().hasSession();
	}

	/**
	 * @return The component currently being rendered in this context
	 */
	public NGComponent component() {
		return _component;
	}

	/**
	 * Set the component currently being rendered in this context
	 */
	public void setComponent( final NGComponent component ) {
		_component = component;
	}

	/**
	 * @return The page-level component
	 */
	public NGComponent page() {
		return _page;

		// CHECKME: Theoretically we can just walk the component tree to get the root level component; i.e. the "page"
		// We're going to have to look into that while considering (a) performance and (b) stateless components
		// Hugi 2025-06-08
		//
		//	NGComponent current = component();
		//
		//	while( current.parent() != null ) {
		//	current = current.parent();
		//	}
		//
		//	return current;
	}

	/**
	 * Set the page-level component currently being rendered by this context.
	 */
	public void setPage( final NGComponent value ) {
		_page = value;
	}

	/**
	 * @return ID of the element currently being rendered by the context.
	 *
	 * CHECKME: Take note of concurrency issues for lazy initialization // Hugi 2023-01-21
	 */
	public String contextID() {
		if( _contextID == null ) {
			_contextID = String.valueOf( session().getContextIDAndIncrement() );

			// Since we're generating a contextID we're going to have to assume our page instance has to be cached, so we mark it as such.
			//
			// CHECKME: This is currently just the best indicator we have that we're involved in stateful work.
			// (i.e. the context's page was the result of a stateful action invocation, or generated stateful URLs that need to reference it)
			// Feels like we could be a little more explicit about this, at the moment this feels just a little like a side effect.
			_shouldSaveInPageCache = true;
		}

		return _contextID;
	}

	/**
	 * Resets the current elementID
	 */
	public void _resetElementID() {
		_elementID = new NGElementID();
	}

	/**
	 * @return ID of the element currently being rendered by the context.
	 */
	public NGElementID elementID() {
		return _elementID;
	}

	/**
	 * @return ID of the element being targeted by a component action
	 */
	public NGElementID senderID() {
		return _senderID;
	}

	/**
	 * Set the senderID
	 */
	public void _setSenderIDFromString( final String senderIDString ) {
		_senderID = NGElementID.fromString( senderIDString );
	}

	/**
	 * @return True if the current element is the sender
	 */
	public boolean currentElementIsSender() {
		return senderID() != null && senderID().equals( elementID() );
	}

	/**
	 * Set the ID of the context that originated the creation of this context.
	 */
	public String _originatingContextID() {
		return _originatingContextID;
	}

	/**
	 * Set the ID of the context that originated the creation of this context.
	 */
	public void _setOriginatingContextID( String value ) {
		_originatingContextID = value;
	}

	/**
	 * @return true if a contextID has been generated for this context, meaning we might want to access that context again.
	 */
	public boolean _shouldSaveInPageCache() {
		return _shouldSaveInPageCache;
	}

	/**
	 * @return The URL for invoking the action in the current context
	 */
	public String componentActionURL() {
		return NGComponentRequestHandler.DEFAULT_PATH + contextID() + "." + elementID();
	}

	/**
	 * @return The names of updateContainers containing the element currently being rendered
	 */
	public List<String> containingUpdateContainerIDs() {
		return _containingUpdateContainerIDs;
	}

	/**
	 * ID of the update containers targeted for rendering this request
	 *
	 * FIXME: Should be replaced with a variable, preferably set at the context's construction // Hugi 2024-10-15
	 * FIXME: We need to decide and document what happens when both a header and parameters are present. One overrides the other? Combine values form both? // Hugi 2025-08-25
	 */
	public String targetedUpdateContainerIDsStringValue() {

		// Start by checking for targeted containers from the request parameters
		final String fromRequestParameters = request().formValueForKey( TARGETED_CONTAINER_ID_PARAM );

		if( fromRequestParameters != null ) {
			return fromRequestParameters;
		}

		return request().headerForKey( TARGETED_CONTAINER_ID_PARAM );
	}

	/**
	 * @return true if we're targeting multiple containers
	 */
	public boolean targetsMultipleUpdateContainers() {
		return targetedUpdateContainerIDsStringValue() != null && targetedUpdateContainerIDsStringValue().contains( MULTIPLE_CONTAINER_SEPARATOR );
	}

	/**
	 * @return The name of the updateContainer to target with the current appendToResponse. In the case of multiple currently matching containers, the first one (the "outermost one") is specified
	 */
	public String updateContainerToAppendTo() {
		if( targetsMultipleUpdateContainers() ) {
			// The list of containers to update is passed in to the request as a header
			final String containerIDToUpdate = targetedUpdateContainerIDsStringValue();

			final String[] updateContainerIDs = containerIDToUpdate.split( MULTIPLE_CONTAINER_SEPARATOR );

			// We return the first matching container, since that should be the outermost container
			for( final String containingContainerID : containingUpdateContainerIDs() ) {
				for( final String targetedContainerID : updateContainerIDs ) {
					if( containingContainerID.equals( targetedContainerID ) ) {
						return containingContainerID;
					}
				}
			}
		}

		return null;
	}

	/**
	 * @return true if the context is currently working inside an updateContainer meant to be updated.
	 *
	 * FIXME: We should probably be caching some of this operation. Even if this isn't heavy, it's going to get invoked for every element on the page // Hugi 20224-07-15
	 */
	public boolean shouldAppendToResponse() {

		if( _forceFullRender ) {
			return true;
		}

		// The list of containers to update is passed in to the request as a header
		final String containerIDToUpdate = targetedUpdateContainerIDsStringValue();

		// If no containers are specified, we're doing a full page render, so always perform appendToResponse()
		if( containerIDToUpdate == null ) {
			return true;
		}

		final String[] updateContainerIDs = containerIDToUpdate.split( MULTIPLE_CONTAINER_SEPARATOR );

		for( String updateContainerID : updateContainerIDs ) {
			if( containingUpdateContainerIDs().contains( updateContainerID ) ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Instructs this context to append every element to the response, ignoring any update container instructions
	 */
	public void setForceFullRender() {
		_forceFullRender = true;
	}

	@Override
	public String toString() {
		return "NGContext [_request=" + _request + ", _component=" + _component + ", _page=" + _page + ", _contextID=" + _contextID + ", _elementID=" + _elementID + ", _senderID=" + _senderID + "]";
	}
}