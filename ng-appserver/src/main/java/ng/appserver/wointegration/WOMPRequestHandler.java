package ng.appserver.wointegration;

import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ng.appserver.NGApplication;
import ng.appserver.NGRequest;
import ng.appserver.NGRequestHandler;
import ng.appserver.NGResponse;
import ng.appserver.resources.NGResource;
import ng.appserver.resources.StandardNamespace;

/**
 * Responds to wotaskd/Monitor requests for:
 *
 *  - Stopping the application
 *  - Gathering statistics
 */

public class WOMPRequestHandler extends NGRequestHandler {

	private static final Logger logger = LoggerFactory.getLogger( WOMPRequestHandler.class );

	public static final String KEY = "womp";
	public static final String DEFAULT_PATH = "/womp/instanceRequest";

	/**
	 * FIXME: Currently just checking for substrings in the requests's XML content. We should be properly deserializing.
	 */
	@Override
	public NGResponse handleRequest( NGRequest request ) {

		if( request.contentString().contains( "TERMINATE" ) ) {
			return terminate();
		}

		if( request.contentString().contains( "STATISTICS" ) ) {
			return statistics();
		}

		if( request.contentString().contains( "REFUSE" ) ) {
			throw new IllegalArgumentException( "REFUSE operation is currently not supported" );
		}

		throw new IllegalArgumentException( "Unknown admin request: " + request + " content: " + request.contentString() );
	}

	/**
	 * FIXME: We're just returning a hardcoded response at the moment. We'll have to consider if we even want to collect these statistics. A job for JFR perhaps.
	 */
	private NGResponse statistics() {
		logger.info( "Returning a statistics response. Those are weird..." );

		final Optional<NGResource> resource = NGApplication.application().resourceManager().obtainAppResource( StandardNamespace.NG.identifier(), "x-statistics-response.xml" );
		final byte[] b = resource.get().bytes();
		return new NGResponse( b, 200 );
	}

	/**
	 * Terminates the application by request from wotaskd and returns a success response
	 */
	private static NGResponse terminate() {
		logger.info( "Terminating application by request from wotaskd..." );

		logger.info( "Sending willStop..." );
		NGDefaultLifeBeatThread._lifebeatThread.sendMessage( NGDefaultLifeBeatThread._lifebeatThread._messageGenerator._willStop );
		logger.info( "Sent willstop." );

		// We perform the shutdown in a thread that executes after we've returned the response to the client.
		// This ensures the application has the opportunity to submit a response to wotaskd before shutting down.
		// Not that pretty but does the job.
		// FIXME: The entire shutdown process should probably be in a shutdown hook // Hugi 2024-08-10
		new Thread( () -> {
			try {
				Thread.sleep( 1000 );
				logger.info( "Exiting" );
				System.exit( 0 );
			}
			catch( final InterruptedException e ) {
				e.printStackTrace();
			}
		} ).start();

		logger.info( "sending command response to wotaskd" );

		final NGResponse response = new NGResponse();
		response.setContentString( """
				<instanceResponse type="NSDictionary">
					<commandInstanceResponse type="NSDictionary">
						<success type="NSString">YES</success>
					</commandInstanceResponse>
				</instanceResponse>""" );
		return response;
	}
}